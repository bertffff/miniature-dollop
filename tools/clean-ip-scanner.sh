#!/bin/bash
#===============================================================================
#
#          FILE: clean-ip-scanner.sh
#
#         USAGE: ./clean-ip-scanner.sh [OPTIONS]
#
#   DESCRIPTION: Clean IP Scanner for CDN Whitelist Bypass
#                Scans CDN IP ranges to find reachable IPs that pass through
#                whitelist-based filtering (like Russian ТСПУ/DPI systems).
#
#        AUTHOR: Generated by Claude (Anthropic)
#       VERSION: 1.0.0
#
#===============================================================================

set -euo pipefail

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly DATA_DIR="${SCRIPT_DIR}/../data"
readonly RESULTS_DIR="${DATA_DIR}/scan_results"
readonly CONFIG_FILE="${DATA_DIR}/config.env"

# Default settings
DEFAULT_TIMEOUT=3
DEFAULT_PARALLEL=50
DEFAULT_TOP_RESULTS=20

# CDN IP Ranges
declare -A CDN_RANGES
CDN_RANGES["gcore"]="92.223.64.0/22 92.223.68.0/22 92.223.72.0/22 92.223.76.0/22 92.223.80.0/22 92.223.84.0/22 92.223.88.0/22 92.223.92.0/22 92.223.96.0/22 92.223.100.0/22 92.223.104.0/22 92.223.108.0/22 92.223.112.0/22 92.223.116.0/22 92.223.120.0/22 92.223.124.0/23 5.188.0.0/22 5.188.4.0/22 5.188.8.0/22 5.188.12.0/22 5.188.16.0/22 5.188.20.0/22 5.188.24.0/22 5.188.28.0/22"
CDN_RANGES["edgecenter"]="5.101.0.0/22 5.101.4.0/22 5.101.8.0/22 5.101.12.0/22 185.251.28.0/22 185.251.30.0/23"
CDN_RANGES["cloudflare"]="173.245.48.0/20 103.21.244.0/22 103.22.200.0/22 103.31.4.0/22 141.101.64.0/18 108.162.192.0/18 190.93.240.0/20 188.114.96.0/20 197.234.240.0/22 198.41.128.0/17 162.158.0.0/15 104.16.0.0/13 104.24.0.0/14 172.64.0.0/13 131.0.72.0/22"

#-------------------------------------------------------------------------------
# Help
#-------------------------------------------------------------------------------
show_help() {
    cat << EOF
Clean IP Scanner v1.0.0

Scans CDN IP ranges to find clean IPs that bypass whitelist filtering.

Usage: $(basename "$0") [OPTIONS]

Options:
    -p, --provider PROVIDER     CDN provider: gcore, edgecenter, cloudflare (default: from config)
    -d, --domain DOMAIN         Domain to test against (default: from config)
    -t, --timeout SECONDS       Connection timeout (default: ${DEFAULT_TIMEOUT})
    -j, --parallel NUM          Parallel connections (default: ${DEFAULT_PARALLEL})
    -n, --top NUM               Number of top results to show (default: ${DEFAULT_TOP_RESULTS})
    -o, --output FILE           Output file for results
    -r, --range CIDR            Custom IP range to scan
    --quick                     Quick scan (fewer IPs, faster)
    --full                      Full scan (all IPs, slower)
    -h, --help                  Show this help message

Examples:
    $(basename "$0")                              # Use settings from config
    $(basename "$0") -p gcore -d cdn.example.com  # Scan GCore for specific domain
    $(basename "$0") -r 92.223.64.0/24 -d test.com # Scan custom range
    $(basename "$0") --quick                      # Quick scan

EOF
}

#-------------------------------------------------------------------------------
# Logging
#-------------------------------------------------------------------------------
log_info() { echo -e "\033[0;34m[INFO]\033[0m $*"; }
log_success() { echo -e "\033[0;32m[OK]\033[0m $*"; }
log_warn() { echo -e "\033[0;33m[WARN]\033[0m $*"; }
log_error() { echo -e "\033[0;31m[ERROR]\033[0m $*" >&2; }

#-------------------------------------------------------------------------------
# Load Configuration
#-------------------------------------------------------------------------------
load_config() {
    if [[ -f "${CONFIG_FILE}" ]]; then
        # shellcheck source=/dev/null
        source "${CONFIG_FILE}"
    fi
}

#-------------------------------------------------------------------------------
# Generate IPs from CIDR
#-------------------------------------------------------------------------------
cidr_to_ips() {
    local cidr="$1"
    local ip mask
    
    IFS='/' read -r ip mask <<< "${cidr}"
    
    # Convert IP to integer
    local IFS='.'
    read -r a b c d <<< "${ip}"
    local ip_int=$(( (a << 24) + (b << 16) + (c << 8) + d ))
    
    # Calculate range
    local host_bits=$((32 - mask))
    local num_hosts=$((2 ** host_bits))
    
    # Generate IPs (skip network and broadcast for /24 and smaller)
    local start=1
    local end=$((num_hosts - 2))
    
    if [[ ${mask} -lt 24 ]]; then
        # For larger ranges, sample IPs
        start=1
        end=$((num_hosts - 2))
        local step=$((num_hosts / 256))
        [[ ${step} -lt 1 ]] && step=1
        
        for ((i = start; i <= end; i += step)); do
            local new_ip=$((ip_int + i))
            echo "$(( (new_ip >> 24) & 255 )).$(( (new_ip >> 16) & 255 )).$(( (new_ip >> 8) & 255 )).$(( new_ip & 255 ))"
        done
    else
        for ((i = start; i <= end; i++)); do
            local new_ip=$((ip_int + i))
            echo "$(( (new_ip >> 24) & 255 )).$(( (new_ip >> 16) & 255 )).$(( (new_ip >> 8) & 255 )).$(( new_ip & 255 ))"
        done
    fi
}

#-------------------------------------------------------------------------------
# Test Single IP
#-------------------------------------------------------------------------------
test_ip() {
    local ip="$1"
    local domain="$2"
    local timeout="$3"
    
    local start_time end_time latency
    start_time=$(date +%s%N)
    
    # Try TLS handshake
    if timeout "${timeout}" openssl s_client \
        -connect "${ip}:443" \
        -servername "${domain}" \
        -verify_quiet \
        -brief \
        </dev/null 2>/dev/null | grep -q "Verification"; then
        
        end_time=$(date +%s%N)
        latency=$(( (end_time - start_time) / 1000000 ))
        echo "${ip}:${latency}"
        return 0
    fi
    
    # Alternative: just check TCP + basic TLS
    if timeout "${timeout}" bash -c "echo | openssl s_client -connect ${ip}:443 -servername ${domain} 2>/dev/null" | grep -q "BEGIN CERTIFICATE"; then
        end_time=$(date +%s%N)
        latency=$(( (end_time - start_time) / 1000000 ))
        echo "${ip}:${latency}"
        return 0
    fi
    
    return 1
}

#-------------------------------------------------------------------------------
# Progress Bar
#-------------------------------------------------------------------------------
show_progress() {
    local current="$1"
    local total="$2"
    local found="$3"
    local width=50
    local percent=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    
    printf "\r["
    printf "%${filled}s" | tr ' ' '#'
    printf "%${empty}s" | tr ' ' '-'
    printf "] %3d%% (%d/%d) Found: %d" "${percent}" "${current}" "${total}" "${found}"
}

#-------------------------------------------------------------------------------
# Main Scan Function
#-------------------------------------------------------------------------------
scan_ips() {
    local provider="$1"
    local domain="$2"
    local timeout="$3"
    local parallel="$4"
    local top_results="$5"
    local custom_range="$6"
    local quick_mode="$7"
    local output_file="$8"
    
    log_info "Starting Clean IP Scanner"
    log_info "Provider: ${provider}"
    log_info "Domain: ${domain}"
    log_info "Timeout: ${timeout}s"
    log_info "Parallel: ${parallel}"
    echo ""
    
    # Get IP ranges
    local ranges
    if [[ -n "${custom_range}" ]]; then
        ranges="${custom_range}"
    else
        ranges="${CDN_RANGES[${provider}]:-}"
        if [[ -z "${ranges}" ]]; then
            log_error "Unknown provider: ${provider}"
            exit 1
        fi
    fi
    
    # Generate IP list
    local temp_ips
    temp_ips=$(mktemp)
    
    log_info "Generating IP list from CIDR ranges..."
    for cidr in ${ranges}; do
        cidr_to_ips "${cidr}" >> "${temp_ips}"
    done
    
    local total_ips
    total_ips=$(wc -l < "${temp_ips}")
    
    # Quick mode: sample IPs
    if [[ "${quick_mode}" == "true" ]]; then
        local sample_ips
        sample_ips=$(mktemp)
        shuf "${temp_ips}" | head -n 500 > "${sample_ips}"
        mv "${sample_ips}" "${temp_ips}"
        total_ips=$(wc -l < "${temp_ips}")
        log_info "Quick mode: Testing ${total_ips} sampled IPs"
    else
        log_info "Testing ${total_ips} IPs"
    fi
    
    echo ""
    
    # Results file
    local results_file
    results_file=$(mktemp)
    
    # Scan with parallel
    local current=0
    local found=0
    
    # Export for parallel
    export -f test_ip
    export domain timeout
    
    # Use xargs for parallel execution with progress
    while IFS= read -r ip; do
        ((current++))
        
        # Test IP
        result=$(test_ip "${ip}" "${domain}" "${timeout}" 2>/dev/null || true)
        if [[ -n "${result}" ]]; then
            echo "${result}" >> "${results_file}"
            ((found++))
        fi
        
        # Show progress every 10 IPs
        if ((current % 10 == 0)) || ((current == total_ips)); then
            show_progress "${current}" "${total_ips}" "${found}"
        fi
    done < "${temp_ips}"
    
    echo ""
    echo ""
    
    # Sort by latency and show results
    if [[ -s "${results_file}" ]]; then
        log_success "Found ${found} clean IPs!"
        echo ""
        
        # Sort by latency
        local sorted_results
        sorted_results=$(mktemp)
        sort -t: -k2 -n "${results_file}" > "${sorted_results}"
        
        echo "════════════════════════════════════════════════════════════"
        echo "                    TOP ${top_results} CLEAN IPs"
        echo "════════════════════════════════════════════════════════════"
        echo ""
        printf "%-20s %15s\n" "IP Address" "Latency (ms)"
        echo "────────────────────────────────────────────────────────────"
        
        head -n "${top_results}" "${sorted_results}" | while IFS=: read -r ip latency; do
            printf "%-20s %15s\n" "${ip}" "${latency}"
        done
        
        echo ""
        echo "════════════════════════════════════════════════════════════"
        
        # Best IP
        local best_ip best_latency
        IFS=: read -r best_ip best_latency < "${sorted_results}"
        echo ""
        log_success "Best IP: ${best_ip} (${best_latency}ms)"
        echo ""
        
        # Save results
        mkdir -p "${RESULTS_DIR}"
        local timestamp
        timestamp=$(date +%Y%m%d_%H%M%S)
        
        if [[ -n "${output_file}" ]]; then
            cp "${sorted_results}" "${output_file}"
            log_info "Results saved to: ${output_file}"
        else
            local default_output="${RESULTS_DIR}/clean_ips_${provider}_${timestamp}.txt"
            cp "${sorted_results}" "${default_output}"
            log_info "Results saved to: ${default_output}"
        fi
        
        # Create summary JSON
        cat > "${RESULTS_DIR}/clean_ips_latest.json" << EOF
{
    "scan_time": "$(date -Iseconds)",
    "provider": "${provider}",
    "domain": "${domain}",
    "total_scanned": ${total_ips},
    "found": ${found},
    "best_ip": "${best_ip}",
    "best_latency_ms": ${best_latency},
    "top_ips": [
$(head -n 5 "${sorted_results}" | while IFS=: read -r ip latency; do
    echo "        {\"ip\": \"${ip}\", \"latency_ms\": ${latency}},"
done | sed '$ s/,$//')
    ]
}
EOF
        
        log_info "Summary saved to: ${RESULTS_DIR}/clean_ips_latest.json"
        
        # Cleanup
        rm -f "${sorted_results}"
    else
        log_warn "No clean IPs found!"
        echo ""
        log_info "Possible reasons:"
        echo "  1. Domain is not configured on the CDN"
        echo "  2. Network is blocking all CDN IPs"
        echo "  3. SSL certificate is not valid for the domain"
        echo ""
        log_info "Try:"
        echo "  - Verify domain is properly configured on ${provider}"
        echo "  - Check if SSL certificate is issued"
        echo "  - Try different CDN provider"
    fi
    
    # Cleanup
    rm -f "${temp_ips}" "${results_file}"
}

#-------------------------------------------------------------------------------
# Interactive Mode
#-------------------------------------------------------------------------------
run_interactive() {
    echo ""
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║              CLEAN IP SCANNER - Interactive Mode             ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo ""
    
    # Load config
    load_config
    
    # Provider selection
    echo "Select CDN provider:"
    echo "  1) GCore (recommended for Russia)"
    echo "  2) EdgeCenter"
    echo "  3) Cloudflare"
    echo ""
    read -rp "Choice [1]: " provider_choice
    
    local provider
    case "${provider_choice:-1}" in
        1) provider="gcore" ;;
        2) provider="edgecenter" ;;
        3) provider="cloudflare" ;;
        *) provider="gcore" ;;
    esac
    
    # Domain
    local default_domain="${CDN_DOMAIN:-}"
    read -rp "Domain to test [${default_domain}]: " domain
    domain="${domain:-${default_domain}}"
    
    if [[ -z "${domain}" ]]; then
        log_error "Domain is required"
        exit 1
    fi
    
    # Scan mode
    echo ""
    echo "Scan mode:"
    echo "  1) Quick (500 IPs, ~1 min)"
    echo "  2) Standard (all IPs, ~5 min)"
    echo ""
    read -rp "Choice [1]: " mode_choice
    
    local quick_mode="true"
    [[ "${mode_choice}" == "2" ]] && quick_mode="false"
    
    echo ""
    
    # Run scan
    scan_ips "${provider}" "${domain}" "${DEFAULT_TIMEOUT}" "${DEFAULT_PARALLEL}" "${DEFAULT_TOP_RESULTS}" "" "${quick_mode}" ""
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------
main() {
    local provider=""
    local domain=""
    local timeout="${DEFAULT_TIMEOUT}"
    local parallel="${DEFAULT_PARALLEL}"
    local top_results="${DEFAULT_TOP_RESULTS}"
    local custom_range=""
    local quick_mode="false"
    local full_mode="false"
    local output_file=""
    
    # Load config for defaults
    load_config
    provider="${CDN_PROVIDER:-gcore}"
    domain="${CDN_DOMAIN:-}"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--provider)
                provider="$2"
                shift 2
                ;;
            -d|--domain)
                domain="$2"
                shift 2
                ;;
            -t|--timeout)
                timeout="$2"
                shift 2
                ;;
            -j|--parallel)
                parallel="$2"
                shift 2
                ;;
            -n|--top)
                top_results="$2"
                shift 2
                ;;
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -r|--range)
                custom_range="$2"
                shift 2
                ;;
            --quick)
                quick_mode="true"
                shift
                ;;
            --full)
                full_mode="true"
                quick_mode="false"
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Interactive mode if no domain specified
    if [[ -z "${domain}" ]] && [[ -z "${custom_range}" ]]; then
        run_interactive
        exit 0
    fi
    
    # Validate
    if [[ -z "${domain}" ]]; then
        log_error "Domain is required. Use -d or --domain"
        exit 1
    fi
    
    # Run scan
    scan_ips "${provider}" "${domain}" "${timeout}" "${parallel}" "${top_results}" "${custom_range}" "${quick_mode}" "${output_file}"
}

main "$@"
