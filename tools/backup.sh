#!/bin/bash
#===============================================================================
#
#          FILE: backup.sh
#
#         USAGE: ./backup.sh [OPTIONS]
#
#   DESCRIPTION: Backup and restore utility for Marzban VPN installation
#
#        AUTHOR: Generated by Claude (Anthropic)
#       VERSION: 1.0.0
#
#===============================================================================

set -euo pipefail

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly DATA_DIR="${SCRIPT_DIR}/../data"
readonly BACKUPS_DIR="${DATA_DIR}/backups"
readonly CONFIG_FILE="${DATA_DIR}/config.env"
readonly KEYS_DIR="${DATA_DIR}/keys"
readonly MARZBAN_DIR="/opt/marzban"
readonly MARZBAN_DATA_DIR="/var/lib/marzban"

# Backup components
readonly BACKUP_COMPONENTS=(
    "config:${DATA_DIR}:Installer configuration"
    "keys:${KEYS_DIR}:Encryption keys"
    "marzban_config:${MARZBAN_DIR}:Marzban configuration"
    "marzban_data:${MARZBAN_DATA_DIR}:Marzban data and database"
    "nginx:/etc/nginx:Nginx configuration"
    "ssl:/etc/letsencrypt:SSL certificates"
)

#-------------------------------------------------------------------------------
# Logging
#-------------------------------------------------------------------------------
log_info() { echo -e "\033[0;34m[INFO]\033[0m $*"; }
log_success() { echo -e "\033[0;32m[OK]\033[0m $*"; }
log_warn() { echo -e "\033[0;33m[WARN]\033[0m $*"; }
log_error() { echo -e "\033[0;31m[ERROR]\033[0m $*" >&2; }

#-------------------------------------------------------------------------------
# Help
#-------------------------------------------------------------------------------
show_help() {
    cat << EOF
Marzban Backup Utility v1.0.0

Usage: $(basename "$0") [COMMAND] [OPTIONS]

Commands:
    backup              Create a new backup (default)
    restore BACKUP      Restore from a backup file
    list                List available backups
    clean               Remove old backups

Options:
    -o, --output FILE   Output backup file path
    -c, --components    Select components to backup (comma-separated)
    -n, --keep NUM      Number of backups to keep (default: 5)
    --encrypt           Encrypt backup with password
    --no-database       Skip database backup
    --quick             Quick backup (config only, no database)
    -h, --help          Show this help message

Components:
    config          Installer configuration files
    keys            Encryption keys (Reality, WARP)
    marzban_config  Marzban docker-compose and env
    marzban_data    Marzban data directory and database
    nginx           Nginx configuration
    ssl             SSL certificates

Examples:
    $(basename "$0")                                # Full backup
    $(basename "$0") backup -o /tmp/backup.tar.gz  # Backup to specific file
    $(basename "$0") backup --quick                # Quick backup (config only)
    $(basename "$0") restore backup_20240101.tar.gz
    $(basename "$0") list
    $(basename "$0") clean -n 3                    # Keep last 3 backups

EOF
}

#-------------------------------------------------------------------------------
# Backup Function
#-------------------------------------------------------------------------------
do_backup() {
    local output_file="$1"
    local components="$2"
    local encrypt="$3"
    local no_database="$4"
    local quick="$5"
    
    log_info "Starting backup..."
    
    # Create temp directory
    local temp_dir
    temp_dir=$(mktemp -d)
    local backup_dir="${temp_dir}/marzban_backup"
    mkdir -p "${backup_dir}"
    
    # Quick mode: only config
    if [[ "${quick}" == "true" ]]; then
        components="config,keys,marzban_config"
    fi
    
    # Backup each component
    IFS=',' read -ra SELECTED_COMPONENTS <<< "${components}"
    
    for component_def in "${BACKUP_COMPONENTS[@]}"; do
        IFS=':' read -r name path description <<< "${component_def}"
        
        # Check if component is selected
        local selected=false
        for sel in "${SELECTED_COMPONENTS[@]}"; do
            if [[ "${sel}" == "${name}" ]] || [[ "${sel}" == "all" ]]; then
                selected=true
                break
            fi
        done
        
        [[ "${selected}" == "false" ]] && continue
        
        # Skip database if requested
        if [[ "${no_database}" == "true" ]] && [[ "${name}" == "marzban_data" ]]; then
            log_info "Skipping ${name} (--no-database)"
            continue
        fi
        
        log_info "Backing up ${name}: ${description}"
        
        if [[ -e "${path}" ]]; then
            local target_dir="${backup_dir}/${name}"
            mkdir -p "${target_dir}"
            
            # For marzban_data, dump database first
            if [[ "${name}" == "marzban_data" ]]; then
                # Check if MariaDB is running
                if docker ps --format '{{.Names}}' | grep -q "mariadb"; then
                    log_info "Dumping MariaDB database..."
                    docker exec mariadb mysqldump -u root -p"${MARIADB_ROOT_PASSWORD:-}" marzban > "${target_dir}/database.sql" 2>/dev/null || true
                fi
                
                # Copy sqlite database if exists
                if [[ -f "${path}/db.sqlite3" ]]; then
                    cp "${path}/db.sqlite3" "${target_dir}/"
                fi
            fi
            
            # Copy files
            cp -a "${path}/." "${target_dir}/" 2>/dev/null || true
            
            log_success "  ${name}: Done"
        else
            log_warn "  ${name}: Path not found (${path})"
        fi
    done
    
    # Add metadata
    cat > "${backup_dir}/backup_info.json" << EOF
{
    "timestamp": "$(date -Iseconds)",
    "hostname": "$(hostname)",
    "version": "$(cat "${DATA_DIR}/version" 2>/dev/null || echo "unknown")",
    "components": "${components}",
    "encrypted": ${encrypt}
}
EOF
    
    # Create archive
    log_info "Creating archive..."
    
    if [[ -z "${output_file}" ]]; then
        mkdir -p "${BACKUPS_DIR}"
        output_file="${BACKUPS_DIR}/marzban_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    fi
    
    if [[ "${encrypt}" == "true" ]]; then
        # Encrypt with openssl
        read -rsp "Enter backup password: " password
        echo ""
        read -rsp "Confirm password: " password2
        echo ""
        
        if [[ "${password}" != "${password2}" ]]; then
            log_error "Passwords do not match"
            rm -rf "${temp_dir}"
            exit 1
        fi
        
        tar -czf - -C "${temp_dir}" marzban_backup | \
            openssl enc -aes-256-cbc -salt -pbkdf2 -pass pass:"${password}" > "${output_file}"
    else
        tar -czf "${output_file}" -C "${temp_dir}" marzban_backup
    fi
    
    # Cleanup
    rm -rf "${temp_dir}"
    
    # Show result
    local backup_size
    backup_size=$(du -h "${output_file}" | cut -f1)
    
    echo ""
    log_success "Backup complete!"
    echo ""
    echo "  File: ${output_file}"
    echo "  Size: ${backup_size}"
    echo ""
}

#-------------------------------------------------------------------------------
# Restore Function
#-------------------------------------------------------------------------------
do_restore() {
    local backup_file="$1"
    local encrypted="$2"
    
    if [[ ! -f "${backup_file}" ]]; then
        log_error "Backup file not found: ${backup_file}"
        exit 1
    fi
    
    log_warn "This will overwrite existing configuration!"
    read -rp "Are you sure you want to continue? [y/N] " confirm
    
    if [[ "${confirm}" != "y" ]] && [[ "${confirm}" != "Y" ]]; then
        log_info "Restore cancelled"
        exit 0
    fi
    
    # Create temp directory
    local temp_dir
    temp_dir=$(mktemp -d)
    
    log_info "Extracting backup..."
    
    # Extract archive
    if [[ "${encrypted}" == "true" ]] || file "${backup_file}" | grep -q "openssl"; then
        read -rsp "Enter backup password: " password
        echo ""
        
        openssl enc -aes-256-cbc -d -salt -pbkdf2 -pass pass:"${password}" -in "${backup_file}" | \
            tar -xzf - -C "${temp_dir}"
    else
        tar -xzf "${backup_file}" -C "${temp_dir}"
    fi
    
    local backup_dir="${temp_dir}/marzban_backup"
    
    if [[ ! -d "${backup_dir}" ]]; then
        log_error "Invalid backup archive"
        rm -rf "${temp_dir}"
        exit 1
    fi
    
    # Show backup info
    if [[ -f "${backup_dir}/backup_info.json" ]]; then
        echo ""
        log_info "Backup information:"
        jq . "${backup_dir}/backup_info.json"
        echo ""
    fi
    
    # Stop services
    log_info "Stopping services..."
    systemctl stop nginx 2>/dev/null || true
    cd "${MARZBAN_DIR}" && docker compose down 2>/dev/null || true
    
    # Restore each component
    for component_def in "${BACKUP_COMPONENTS[@]}"; do
        IFS=':' read -r name path description <<< "${component_def}"
        
        local source_dir="${backup_dir}/${name}"
        
        if [[ -d "${source_dir}" ]]; then
            log_info "Restoring ${name}..."
            
            # Backup current
            if [[ -e "${path}" ]]; then
                mv "${path}" "${path}.bak.$(date +%s)" 2>/dev/null || true
            fi
            
            # Restore
            mkdir -p "$(dirname "${path}")"
            cp -a "${source_dir}" "${path}"
            
            # Special handling for database
            if [[ "${name}" == "marzban_data" ]] && [[ -f "${source_dir}/database.sql" ]]; then
                log_info "Database dump found, will restore after services start"
            fi
            
            log_success "  ${name}: Restored"
        fi
    done
    
    # Fix permissions
    chmod 600 "${CONFIG_FILE}" 2>/dev/null || true
    chmod 700 "${KEYS_DIR}" 2>/dev/null || true
    
    # Start services
    log_info "Starting services..."
    cd "${MARZBAN_DIR}" && docker compose up -d
    systemctl start nginx
    
    # Restore MariaDB database if needed
    if [[ -f "${backup_dir}/marzban_data/database.sql" ]]; then
        log_info "Waiting for MariaDB to start..."
        sleep 10
        
        if docker ps --format '{{.Names}}' | grep -q "mariadb"; then
            log_info "Restoring MariaDB database..."
            docker exec -i mariadb mysql -u root -p"${MARIADB_ROOT_PASSWORD:-}" marzban < "${backup_dir}/marzban_data/database.sql" 2>/dev/null || true
        fi
    fi
    
    # Cleanup
    rm -rf "${temp_dir}"
    
    echo ""
    log_success "Restore complete!"
    log_info "Please verify all services are running correctly."
}

#-------------------------------------------------------------------------------
# List Backups
#-------------------------------------------------------------------------------
list_backups() {
    if [[ ! -d "${BACKUPS_DIR}" ]]; then
        log_info "No backups directory found"
        return
    fi
    
    echo ""
    echo "Available backups:"
    echo "═══════════════════════════════════════════════════════════════════"
    echo ""
    
    local count=0
    
    while IFS= read -r backup_file; do
        [[ -z "${backup_file}" ]] && continue
        
        ((count++))
        
        local filename
        filename=$(basename "${backup_file}")
        local size
        size=$(du -h "${backup_file}" | cut -f1)
        local modified
        modified=$(stat -c %y "${backup_file}" | cut -d. -f1)
        
        printf "  %2d) %-45s %8s  %s\n" "${count}" "${filename}" "${size}" "${modified}"
    done < <(find "${BACKUPS_DIR}" -name "*.tar.gz" -type f 2>/dev/null | sort -r)
    
    if [[ ${count} -eq 0 ]]; then
        echo "  No backups found"
    fi
    
    echo ""
}

#-------------------------------------------------------------------------------
# Clean Old Backups
#-------------------------------------------------------------------------------
clean_backups() {
    local keep="$1"
    
    if [[ ! -d "${BACKUPS_DIR}" ]]; then
        log_info "No backups directory found"
        return
    fi
    
    local total
    total=$(find "${BACKUPS_DIR}" -name "*.tar.gz" -type f 2>/dev/null | wc -l)
    
    if [[ ${total} -le ${keep} ]]; then
        log_info "Found ${total} backups, keeping ${keep}. Nothing to clean."
        return
    fi
    
    local to_remove=$((total - keep))
    
    log_info "Found ${total} backups, keeping ${keep}, removing ${to_remove}..."
    
    find "${BACKUPS_DIR}" -name "*.tar.gz" -type f -printf '%T+ %p\n' 2>/dev/null | \
        sort | head -n "${to_remove}" | cut -d' ' -f2- | while read -r file; do
            log_info "Removing: $(basename "${file}")"
            rm -f "${file}"
        done
    
    log_success "Cleanup complete"
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------
main() {
    local command="backup"
    local output_file=""
    local components="all"
    local encrypt="false"
    local no_database="false"
    local quick="false"
    local keep=5
    local restore_file=""
    
    # Load config
    if [[ -f "${CONFIG_FILE}" ]]; then
        # shellcheck source=/dev/null
        source "${CONFIG_FILE}"
    fi
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            backup|restore|list|clean)
                command="$1"
                if [[ "$1" == "restore" ]] && [[ -n "${2:-}" ]] && [[ ! "$2" =~ ^- ]]; then
                    restore_file="$2"
                    shift
                fi
                shift
                ;;
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -c|--components)
                components="$2"
                shift 2
                ;;
            -n|--keep)
                keep="$2"
                shift 2
                ;;
            --encrypt)
                encrypt="true"
                shift
                ;;
            --no-database)
                no_database="true"
                shift
                ;;
            --quick)
                quick="true"
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                # Check if it's a restore file
                if [[ -f "$1" ]]; then
                    command="restore"
                    restore_file="$1"
                else
                    log_error "Unknown option: $1"
                    show_help
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Execute command
    case "${command}" in
        backup)
            do_backup "${output_file}" "${components}" "${encrypt}" "${no_database}" "${quick}"
            ;;
        restore)
            if [[ -z "${restore_file}" ]]; then
                log_error "Backup file required for restore"
                exit 1
            fi
            do_restore "${restore_file}" "${encrypt}"
            ;;
        list)
            list_backups
            ;;
        clean)
            clean_backups "${keep}"
            ;;
    esac
}

main "$@"
