#!/bin/bash
#===============================================================================
#
#          FILE: health-check.sh
#
#         USAGE: ./health-check.sh [OPTIONS]
#
#   DESCRIPTION: Comprehensive health check for Marzban VPN installation
#                Verifies all components are working correctly.
#
#        AUTHOR: Generated by Claude (Anthropic)
#       VERSION: 1.0.0
#
#===============================================================================

set -euo pipefail

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly DATA_DIR="${SCRIPT_DIR}/../data"
readonly CONFIG_FILE="${DATA_DIR}/config.env"
readonly KEYS_DIR="${DATA_DIR}/keys"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Counters
CHECKS_PASSED=0
CHECKS_FAILED=0
CHECKS_WARNED=0
CHECKS_TOTAL=0

#-------------------------------------------------------------------------------
# Output Functions
#-------------------------------------------------------------------------------
check_pass() {
    echo -e "${GREEN}✓${NC} $*"
    ((CHECKS_PASSED++))
    ((CHECKS_TOTAL++))
}

check_fail() {
    echo -e "${RED}✗${NC} $*"
    ((CHECKS_FAILED++))
    ((CHECKS_TOTAL++))
}

check_warn() {
    echo -e "${YELLOW}!${NC} $*"
    ((CHECKS_WARNED++))
    ((CHECKS_TOTAL++))
}

check_info() {
    echo -e "${BLUE}ℹ${NC} $*"
}

section_header() {
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  $*"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

#-------------------------------------------------------------------------------
# Load Configuration
#-------------------------------------------------------------------------------
load_config() {
    if [[ -f "${CONFIG_FILE}" ]]; then
        # shellcheck source=/dev/null
        source "${CONFIG_FILE}"
        return 0
    fi
    return 1
}

#-------------------------------------------------------------------------------
# System Checks
#-------------------------------------------------------------------------------
check_system() {
    section_header "SYSTEM CHECKS"
    
    # OS Version
    if [[ -f /etc/os-release ]]; then
        # shellcheck source=/dev/null
        source /etc/os-release
        check_info "OS: ${PRETTY_NAME:-${NAME} ${VERSION_ID}}"
    fi
    
    # Kernel
    local kernel_version
    kernel_version=$(uname -r)
    check_info "Kernel: ${kernel_version}"
    
    if [[ "${kernel_version}" == *"xanmod"* ]]; then
        check_pass "XanMod kernel is installed"
    else
        check_info "Standard kernel (XanMod not installed)"
    fi
    
    # Architecture
    local arch
    arch=$(uname -m)
    if [[ "${arch}" == "x86_64" ]]; then
        check_pass "Architecture: ${arch}"
    else
        check_warn "Architecture: ${arch} (x86_64 recommended)"
    fi
    
    # Memory
    local mem_total mem_available mem_percent
    mem_total=$(free -m | awk '/^Mem:/{print $2}')
    mem_available=$(free -m | awk '/^Mem:/{print $7}')
    mem_percent=$((mem_available * 100 / mem_total))
    
    if [[ ${mem_percent} -gt 20 ]]; then
        check_pass "Memory: ${mem_available}MB available (${mem_percent}% free)"
    elif [[ ${mem_percent} -gt 10 ]]; then
        check_warn "Memory: ${mem_available}MB available (${mem_percent}% free) - Low"
    else
        check_fail "Memory: ${mem_available}MB available (${mem_percent}% free) - Critical"
    fi
    
    # Disk
    local disk_available disk_percent
    disk_available=$(df -BG / | awk 'NR==2 {print $4}' | tr -d 'G')
    disk_percent=$(df / | awk 'NR==2 {print $5}' | tr -d '%')
    
    if [[ ${disk_percent} -lt 80 ]]; then
        check_pass "Disk: ${disk_available}GB available (${disk_percent}% used)"
    elif [[ ${disk_percent} -lt 90 ]]; then
        check_warn "Disk: ${disk_available}GB available (${disk_percent}% used) - Low"
    else
        check_fail "Disk: ${disk_available}GB available (${disk_percent}% used) - Critical"
    fi
    
    # Load average
    local load_1m load_5m load_15m cpus
    read -r load_1m load_5m load_15m _ < /proc/loadavg
    cpus=$(nproc)
    
    check_info "Load Average: ${load_1m}, ${load_5m}, ${load_15m} (${cpus} CPUs)"
}

#-------------------------------------------------------------------------------
# Network Checks
#-------------------------------------------------------------------------------
check_network() {
    section_header "NETWORK CHECKS"
    
    # Public IP
    local public_ip
    public_ip=$(curl -s -4 --max-time 5 ifconfig.me 2>/dev/null || echo "")
    
    if [[ -n "${public_ip}" ]]; then
        check_pass "Public IPv4: ${public_ip}"
    else
        check_warn "Could not determine public IPv4"
    fi
    
    # IPv6
    local public_ipv6
    public_ipv6=$(curl -s -6 --max-time 5 ifconfig.me 2>/dev/null || echo "")
    
    if [[ -n "${public_ipv6}" ]]; then
        check_info "Public IPv6: ${public_ipv6}"
    fi
    
    # BBR
    local congestion_control
    congestion_control=$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null || echo "unknown")
    
    if [[ "${congestion_control}" == "bbr" ]]; then
        check_pass "TCP Congestion Control: BBR enabled"
    else
        check_warn "TCP Congestion Control: ${congestion_control} (BBR recommended)"
    fi
    
    # DNS Resolution
    if host google.com &>/dev/null; then
        check_pass "DNS Resolution: Working"
    else
        check_fail "DNS Resolution: Failed"
    fi
    
    # Port 443
    if ss -tlnp | grep -q ":443 "; then
        check_pass "Port 443: Listening"
    else
        check_fail "Port 443: Not listening"
    fi
    
    # Port 80
    if ss -tlnp | grep -q ":80 "; then
        check_pass "Port 80: Listening"
    else
        check_warn "Port 80: Not listening (may be needed for SSL)"
    fi
}

#-------------------------------------------------------------------------------
# Docker Checks
#-------------------------------------------------------------------------------
check_docker() {
    section_header "DOCKER CHECKS"
    
    # Docker service
    if systemctl is-active --quiet docker; then
        check_pass "Docker service: Running"
    else
        check_fail "Docker service: Not running"
        return
    fi
    
    # Docker version
    local docker_version
    docker_version=$(docker version --format '{{.Server.Version}}' 2>/dev/null || echo "unknown")
    check_info "Docker version: ${docker_version}"
    
    # Docker Compose
    if docker compose version &>/dev/null; then
        local compose_version
        compose_version=$(docker compose version --short 2>/dev/null || echo "unknown")
        check_pass "Docker Compose: v${compose_version}"
    else
        check_fail "Docker Compose: Not installed"
    fi
    
    # Running containers
    local containers
    containers=$(docker ps --format '{{.Names}}' 2>/dev/null | wc -l)
    check_info "Running containers: ${containers}"
    
    # Marzban container
    if docker ps --format '{{.Names}}' | grep -q "marzban"; then
        local marzban_status
        marzban_status=$(docker inspect --format '{{.State.Status}}' marzban 2>/dev/null || echo "unknown")
        
        if [[ "${marzban_status}" == "running" ]]; then
            check_pass "Marzban container: Running"
            
            # Container health
            local marzban_health
            marzban_health=$(docker inspect --format '{{.State.Health.Status}}' marzban 2>/dev/null || echo "none")
            if [[ "${marzban_health}" != "none" ]]; then
                check_info "Marzban health: ${marzban_health}"
            fi
        else
            check_fail "Marzban container: ${marzban_status}"
        fi
    else
        check_fail "Marzban container: Not found"
    fi
    
    # MariaDB container (if enabled)
    if [[ "${DATABASE_TYPE:-}" == "mariadb" ]]; then
        if docker ps --format '{{.Names}}' | grep -q "mariadb"; then
            check_pass "MariaDB container: Running"
        else
            check_fail "MariaDB container: Not found"
        fi
    fi
    
    # AdGuard container (if enabled)
    if [[ "${ADGUARD_ENABLED:-}" == "true" ]]; then
        if docker ps --format '{{.Names}}' | grep -q "adguard"; then
            check_pass "AdGuard container: Running"
        else
            check_fail "AdGuard container: Not found"
        fi
    fi
}

#-------------------------------------------------------------------------------
# Nginx Checks
#-------------------------------------------------------------------------------
check_nginx() {
    section_header "NGINX CHECKS"
    
    # Nginx service
    if systemctl is-active --quiet nginx; then
        check_pass "Nginx service: Running"
    else
        check_fail "Nginx service: Not running"
        return
    fi
    
    # Nginx version
    local nginx_version
    nginx_version=$(nginx -v 2>&1 | grep -oP 'nginx/\K[0-9.]+' || echo "unknown")
    check_info "Nginx version: ${nginx_version}"
    
    # Config test
    if nginx -t &>/dev/null; then
        check_pass "Nginx config: Valid"
    else
        check_fail "Nginx config: Invalid"
    fi
    
    # Stream module
    if nginx -V 2>&1 | grep -q "with-stream"; then
        check_pass "Nginx stream module: Enabled"
    else
        check_warn "Nginx stream module: Not detected"
    fi
}

#-------------------------------------------------------------------------------
# SSL Checks
#-------------------------------------------------------------------------------
check_ssl() {
    section_header "SSL CERTIFICATE CHECKS"
    
    # Skip if SSL is managed by CDN
    if [[ "${SSL_MANAGED_BY_CDN:-false}" == "true" ]]; then
        check_info "SSL is managed by CDN"
        return
    fi
    
    local domain="${PANEL_DOMAIN:-}"
    
    if [[ -z "${domain}" ]]; then
        check_warn "Panel domain not configured"
        return
    fi
    
    local cert_path="/etc/letsencrypt/live/${domain}/fullchain.pem"
    
    if [[ -f "${cert_path}" ]]; then
        check_pass "Certificate file exists: ${cert_path}"
        
        # Check expiry
        local expiry_date expiry_epoch now_epoch days_left
        expiry_date=$(openssl x509 -enddate -noout -in "${cert_path}" 2>/dev/null | cut -d= -f2)
        expiry_epoch=$(date -d "${expiry_date}" +%s 2>/dev/null || echo "0")
        now_epoch=$(date +%s)
        days_left=$(( (expiry_epoch - now_epoch) / 86400 ))
        
        if [[ ${days_left} -gt 30 ]]; then
            check_pass "Certificate expires in ${days_left} days"
        elif [[ ${days_left} -gt 7 ]]; then
            check_warn "Certificate expires in ${days_left} days"
        elif [[ ${days_left} -gt 0 ]]; then
            check_fail "Certificate expires in ${days_left} days - RENEW NOW"
        else
            check_fail "Certificate has EXPIRED"
        fi
        
        # Check domain match
        local cert_domains
        cert_domains=$(openssl x509 -noout -text -in "${cert_path}" 2>/dev/null | grep -A1 "Subject Alternative Name" | tail -1 | tr ',' '\n' | grep DNS | sed 's/.*DNS://' | tr '\n' ' ')
        check_info "Certificate domains: ${cert_domains}"
        
    else
        check_fail "Certificate not found: ${cert_path}"
    fi
    
    # Certbot timer
    if systemctl is-active --quiet certbot.timer; then
        check_pass "Certbot auto-renewal: Active"
    else
        check_warn "Certbot auto-renewal: Not active"
    fi
}

#-------------------------------------------------------------------------------
# Firewall Checks
#-------------------------------------------------------------------------------
check_firewall() {
    section_header "FIREWALL CHECKS"
    
    # UFW status
    local ufw_status
    ufw_status=$(ufw status 2>/dev/null | head -1 || echo "unknown")
    
    if [[ "${ufw_status}" == *"active"* ]]; then
        check_pass "UFW: Active"
        
        # Check essential rules
        if ufw status | grep -q "443.*ALLOW"; then
            check_pass "Port 443: Allowed"
        else
            check_fail "Port 443: Not allowed"
        fi
        
        if ufw status | grep -q "80.*ALLOW"; then
            check_pass "Port 80: Allowed"
        else
            check_warn "Port 80: Not allowed"
        fi
        
        # SSH
        local ssh_port
        ssh_port=$(grep -E "^Port " /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}' || echo "22")
        if ufw status | grep -q "${ssh_port}.*ALLOW"; then
            check_pass "SSH port ${ssh_port}: Allowed"
        else
            check_warn "SSH port ${ssh_port}: Not explicitly allowed"
        fi
        
    else
        check_warn "UFW: ${ufw_status}"
    fi
    
    # Fail2Ban
    if [[ "${FAIL2BAN_ENABLED:-}" == "true" ]]; then
        if systemctl is-active --quiet fail2ban; then
            check_pass "Fail2Ban: Active"
            
            local banned
            banned=$(fail2ban-client status sshd 2>/dev/null | grep "Currently banned" | awk '{print $NF}' || echo "0")
            check_info "SSH banned IPs: ${banned}"
        else
            check_fail "Fail2Ban: Not running"
        fi
    fi
}

#-------------------------------------------------------------------------------
# Xray Checks
#-------------------------------------------------------------------------------
check_xray() {
    section_header "XRAY CHECKS"
    
    # Check if Xray is running (via Marzban logs or process)
    if docker exec marzban pgrep xray &>/dev/null; then
        check_pass "Xray process: Running"
    else
        check_warn "Xray process: Not detected (checking alternative method)"
        
        # Check Marzban API
        if curl -s --max-time 5 http://localhost:8000/api/ &>/dev/null; then
            check_pass "Marzban API: Responding"
        else
            check_fail "Marzban API: Not responding"
        fi
    fi
    
    # Reality keys
    local reality_keys="${KEYS_DIR}/reality_keys.json"
    if [[ -f "${reality_keys}" ]]; then
        check_pass "Reality keys: Found"
        
        if jq . "${reality_keys}" &>/dev/null; then
            local public_key
            public_key=$(jq -r '.public_key' "${reality_keys}" 2>/dev/null || echo "")
            if [[ -n "${public_key}" ]]; then
                check_info "Reality public key: ${public_key:0:20}..."
            fi
        fi
    else
        check_warn "Reality keys: Not found"
    fi
    
    # WARP config (if enabled)
    if [[ "${PROFILE_WARP_ENABLED:-}" == "true" ]]; then
        local warp_config="${KEYS_DIR}/warp_config.json"
        if [[ -f "${warp_config}" ]]; then
            check_pass "WARP config: Found"
        else
            check_warn "WARP config: Not found"
        fi
    fi
}

#-------------------------------------------------------------------------------
# Connectivity Checks
#-------------------------------------------------------------------------------
check_connectivity() {
    section_header "CONNECTIVITY CHECKS"
    
    local domain="${PANEL_DOMAIN:-}"
    
    if [[ -z "${domain}" ]]; then
        check_warn "Panel domain not configured, skipping connectivity checks"
        return
    fi
    
    # HTTP check
    local http_code
    http_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "http://${domain}" 2>/dev/null || echo "000")
    
    if [[ "${http_code}" == "200" ]] || [[ "${http_code}" == "301" ]] || [[ "${http_code}" == "302" ]]; then
        check_pass "HTTP (${domain}): ${http_code}"
    elif [[ "${http_code}" == "000" ]]; then
        check_warn "HTTP (${domain}): Connection failed"
    else
        check_info "HTTP (${domain}): ${http_code}"
    fi
    
    # HTTPS check
    local https_code
    https_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k "https://${domain}" 2>/dev/null || echo "000")
    
    if [[ "${https_code}" == "200" ]] || [[ "${https_code}" == "301" ]] || [[ "${https_code}" == "302" ]]; then
        check_pass "HTTPS (${domain}): ${https_code}"
    elif [[ "${https_code}" == "000" ]]; then
        check_fail "HTTPS (${domain}): Connection failed"
    else
        check_info "HTTPS (${domain}): ${https_code}"
    fi
    
    # Panel API check
    local api_code
    api_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k "https://${domain}/api/" 2>/dev/null || echo "000")
    
    if [[ "${api_code}" == "200" ]] || [[ "${api_code}" == "401" ]] || [[ "${api_code}" == "404" ]]; then
        check_pass "Panel API: Responding (${api_code})"
    else
        check_warn "Panel API: ${api_code}"
    fi
    
    # Reality connection test (if configured)
    local reality_dest="${REALITY_DEST:-www.microsoft.com}"
    local reality_port="${REALITY_PORT:-443}"
    
    if timeout 5 bash -c "echo | openssl s_client -connect ${reality_dest}:${reality_port} 2>/dev/null" | grep -q "BEGIN CERTIFICATE"; then
        check_pass "Reality destination (${reality_dest}): Reachable"
    else
        check_warn "Reality destination (${reality_dest}): Not reachable"
    fi
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------
main() {
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║           MARZBAN VPN HEALTH CHECK                               ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    
    # Load configuration
    load_config
    
    # Run all checks
    check_system
    check_network
    check_docker
    check_nginx
    check_ssl
    check_firewall
    check_xray
    check_connectivity
    
    # Summary
    section_header "SUMMARY"
    echo ""
    echo -e "  ${GREEN}Passed:${NC}  ${CHECKS_PASSED}"
    echo -e "  ${YELLOW}Warnings:${NC} ${CHECKS_WARNED}"
    echo -e "  ${RED}Failed:${NC}  ${CHECKS_FAILED}"
    echo -e "  Total:   ${CHECKS_TOTAL}"
    echo ""
    
    if [[ ${CHECKS_FAILED} -eq 0 ]]; then
        if [[ ${CHECKS_WARNED} -eq 0 ]]; then
            echo -e "${GREEN}All checks passed! Your installation is healthy.${NC}"
        else
            echo -e "${YELLOW}Installation is working, but there are some warnings to review.${NC}"
        fi
        exit 0
    else
        echo -e "${RED}Some checks failed. Please review the issues above.${NC}"
        exit 1
    fi
}

# Run
main "$@"
