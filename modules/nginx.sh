#!/bin/bash
#
# Module: nginx.sh
# Purpose: Nginx installation and SNI routing configuration
# Dependencies: core.sh
#
# ИСПРАВЛЕНО: Конфликт порта 443 между nginx и xray
# - Nginx stream слушает порт 443 и маршрутизирует по SNI
# - Xray слушает только на localhost (127.0.0.1)
# - Добавлена поддержка ACME challenge через порт 80

# Strict mode
set -euo pipefail

# Source core module
if [[ -z "${SCRIPT_DIR:-}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    source "${SCRIPT_DIR}/core.sh"
fi

# ═══════════════════════════════════════════════════════════════════════════════
# CONSTANTS
# ═══════════════════════════════════════════════════════════════════════════════

readonly NGINX_CONF_DIR="/etc/nginx"
readonly NGINX_STREAM_DIR="/etc/nginx/stream.conf.d"
readonly NGINX_SITES_DIR="/etc/nginx/conf.d"
readonly NGINX_WEBROOT="/var/www/html"

# ═══════════════════════════════════════════════════════════════════════════════
# NGINX INSTALLATION
# ═══════════════════════════════════════════════════════════════════════════════

is_nginx_installed() {
    command -v nginx &> /dev/null
}

install_nginx() {
    set_phase "Nginx Installation"
    
    if is_nginx_installed; then
        log_info "Nginx already installed"
        return 0
    fi
    
    log_info "Installing Nginx..."
    
    install_packages nginx libnginx-mod-stream
    
    # Ensure nginx is stopped for initial configuration
    systemctl stop nginx 2>/dev/null || true
    
    register_rollback "apt-get remove -y nginx" "normal"
    
    log_success "Nginx installed"
}

# ═══════════════════════════════════════════════════════════════════════════════
# NGINX MAIN CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

configure_nginx_main() {
    set_phase "Nginx Main Configuration"
    
    log_info "Configuring nginx.conf..."
    
    # Backup original configuration
    if [[ -f "${NGINX_CONF_DIR}/nginx.conf" ]]; then
        cp "${NGINX_CONF_DIR}/nginx.conf" "${NGINX_CONF_DIR}/nginx.conf.backup"
    fi
    
    # Create main nginx.conf
    cat > "${NGINX_CONF_DIR}/nginx.conf" << 'EOF'
# Nginx Main Configuration
# Generated by Marzban Ultimate VPN Installer

user www-data;
worker_processes auto;
worker_rlimit_nofile 65535;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 65535;
    use epoll;
    multi_accept on;
}

http {
    ##
    # Basic Settings
    ##
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_tokens off;
    
    # Buffer settings
    client_body_buffer_size 16k;
    client_header_buffer_size 1k;
    client_max_body_size 50M;
    large_client_header_buffers 4 8k;
    
    # Timeouts
    client_body_timeout 12;
    client_header_timeout 12;
    send_timeout 10;
    
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings
    ##
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305;
    ssl_session_cache shared:SSL:50m;
    ssl_session_timeout 1d;
    ssl_session_tickets off;

    ##
    # Logging Settings
    ##
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript application/xml;

    ##
    # Virtual Host Configs
    ##
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}

# Stream module for SNI routing (TCP proxy)
# ВАЖНО: Только stream модуль слушает порт 443!
stream {
    # Fix for map_hash_bucket_size error
    map_hash_bucket_size 128;

    log_format stream_log '$remote_addr [$time_local] '
                          '$protocol $status $bytes_sent $bytes_received '
                          '$session_time "$upstream_addr" '
                          '"$ssl_preread_server_name"';
    
    access_log /var/log/nginx/stream.log stream_log;
    
    include /etc/nginx/stream.conf.d/*.conf;
}
EOF
    
    register_rollback "rm -f ${NGINX_CONF_DIR}/nginx.conf" "normal"
    
    # Create stream directory
    mkdir -p "${NGINX_STREAM_DIR}"
    mkdir -p "${NGINX_SITES_DIR}"
}

# ═══════════════════════════════════════════════════════════════════════════════
# SNI ROUTING CONFIGURATION (PORT 443)
# ═══════════════════════════════════════════════════════════════════════════════

configure_sni_routing() {
    set_phase "SNI Routing Configuration"
    
    log_info "Configuring SNI-based routing..."
    
    # Ensure Reality destination is set
    local reality_dest="${REALITY_DEST:-www.microsoft.com}"
    local panel_domain="${PANEL_DOMAIN:-}"
    local cdn_domain="${CDN_DOMAIN:-}"

    # Валидация портов - Xray слушает ТОЛЬКО на localhost
    local reality_port="${REALITY_PORT:-8443}"
    if [[ ! "${reality_port}" =~ ^[0-9]+$ ]]; then
        reality_port="8443"
    fi

    local ws_port="${WS_PORT:-8444}"
    if [[ ! "${ws_port}" =~ ^[0-9]+$ ]]; then
        ws_port="8444"
    fi

    local marzban_port="${MARZBAN_PORT:-8000}"
    if [[ ! "${marzban_port}" =~ ^[0-9]+$ ]]; then
        marzban_port="8000"
    fi
    
    # Create SNI routing configuration
    cat > "${NGINX_STREAM_DIR}/sni-router.conf" << EOF
# SNI-based traffic routing
# Generated by Marzban Ultimate Installer
# 
# АРХИТЕКТУРА:
# - Nginx stream слушает порт 443 (единственный сервис на этом порту!)
# - По SNI маршрутизирует на внутренние порты
# - Xray слушает ТОЛЬКО на 127.0.0.1 (localhost)

# SNI to backend mapping
map \$ssl_preread_server_name \$backend {
    # Reality profile - forward to Xray Reality handler
    # Эти домены имитируют легитимный трафик
    ~^(www\.)?(microsoft|apple|samsung|nvidia|google)\.com\$    xray_reality;
    ~^dl\.google\.com\$                                          xray_reality;
    
EOF

    # Add panel domain if configured
    if [[ -n "${panel_domain}" ]]; then
        cat >> "${NGINX_STREAM_DIR}/sni-router.conf" << EOF
    # Panel domain - proxy to Nginx HTTP block for SSL Termination
    "${panel_domain}"                                            marzban_panel;
    
EOF
    fi
    
    # Add CDN domain if configured
    if [[ -n "${cdn_domain}" ]]; then
        cat >> "${NGINX_STREAM_DIR}/sni-router.conf" << EOF
    # CDN domain - forward to Xray WebSocket handler
    "${cdn_domain}"                                              xray_websocket;
    
EOF
    fi
    
    # Add default fallback
    cat >> "${NGINX_STREAM_DIR}/sni-router.conf" << EOF
    # Default - serve fake website (camouflage)
    default                                                      fake_site;
}

# ═══════════════════════════════════════════════════════════════════════════════
# UPSTREAM DEFINITIONS
# Все upstream указывают на localhost - никаких внешних портов!
# ═══════════════════════════════════════════════════════════════════════════════

# Xray Reality - VLESS+Reality protocol (основной VPN профиль)
upstream xray_reality {
    server 127.0.0.1:${reality_port};
}

# Xray WebSocket - для CDN/whitelist bypass профиля
upstream xray_websocket {
    server 127.0.0.1:${ws_port};
}

# Marzban Panel - через nginx http block для SSL termination
upstream marzban_panel {
    server 127.0.0.1:8081;
}

# Fake site - камуфляж для неизвестных SNI
upstream fake_site {
    server 127.0.0.1:8080;
}

# ═══════════════════════════════════════════════════════════════════════════════
# MAIN LISTENER - ЕДИНСТВЕННЫЙ СЕРВИС НА ПОРТУ 443!
# ═══════════════════════════════════════════════════════════════════════════════
server {
    # Слушаем на всех интерфейсах, порт 443
    listen 443 reuseport;
    listen [::]:443 reuseport;
    
    # Маршрутизация по SNI
    proxy_pass \$backend;
    proxy_protocol off;
    
    # Читаем SNI без расшифровки TLS
    ssl_preread on;
    
    # Proxy settings
    proxy_connect_timeout 10s;
    proxy_timeout 300s;
    proxy_buffer_size 16k;
    
    # TCP optimizations
    proxy_socket_keepalive on;
}
EOF
    
    register_rollback "rm -f ${NGINX_STREAM_DIR}/sni-router.conf" "normal"
    
    log_success "SNI routing configured"
}

# ═══════════════════════════════════════════════════════════════════════════════
# MARZBAN PANEL SSL TERMINATION (PORT 8081)
# ═══════════════════════════════════════════════════════════════════════════════

configure_marzban_panel_server() {
    local domain="${PANEL_DOMAIN:-}"
    local marzban_port="${MARZBAN_PORT:-8000}"
    
    if [[ -z "${domain}" ]]; then return 0; fi
    
    log_info "Configuring Marzban Panel SSL termination..."
    
    # Проверяем наличие сертификата
    local cert_path="/etc/letsencrypt/live/${domain}"
    if [[ ! -f "${cert_path}/fullchain.pem" ]]; then
        log_warn "Certificate not found for ${domain}, skipping panel SSL config"
        log_info "Run 'certbot certonly' first, then restart nginx"
        return 0
    fi
    
    cat > "${NGINX_CONF_DIR}/conf.d/marzban-panel.conf" << EOF
# Marzban Panel SSL Termination
# Nginx терминирует SSL, затем проксирует на Marzban (HTTP)
# 
# Поток: Client -> Nginx:443 (SNI routing) -> Nginx:8081 (SSL termination) -> Marzban:8000

server {
    # Слушаем ТОЛЬКО на localhost - внешний доступ через stream module
    listen 127.0.0.1:8081 ssl http2;
    server_name ${domain};
    
    # SSL Certificates (Let's Encrypt)
    ssl_certificate ${cert_path}/fullchain.pem;
    ssl_certificate_key ${cert_path}/privkey.pem;
    
    # Modern SSL settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Proxy to Marzban (HTTP, no SSL)
    location / {
        proxy_pass http://127.0.0.1:${marzban_port};
        proxy_http_version 1.1;
        
        # WebSocket support для real-time updates
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Preserve client info
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # API endpoint
    location /api {
        proxy_pass http://127.0.0.1:${marzban_port}/api;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}
EOF

    log_success "Marzban Panel SSL config created"
}

# ═══════════════════════════════════════════════════════════════════════════════
# ACME CHALLENGE SERVER (PORT 80) - КРИТИЧНО ДЛЯ CERTBOT!
# ═══════════════════════════════════════════════════════════════════════════════

configure_acme_challenge_server() {
    set_phase "ACME Challenge Server Configuration"
    
    log_info "Configuring ACME challenge server on port 80..."
    
    mkdir -p "${NGINX_WEBROOT}/.well-known/acme-challenge"
    
    cat > "${NGINX_CONF_DIR}/conf.d/acme-challenge.conf" << 'EOF'
# ACME Challenge Server
# Обрабатывает HTTP-01 challenge от Let's Encrypt
# 
# ВАЖНО: Этот сервер должен быть доступен на порту 80!

server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    
    # ACME challenge location - must be accessible
    location /.well-known/acme-challenge/ {
        root /var/www/html;
        allow all;
    }
    
    # Redirect all other traffic to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}
EOF

    register_rollback "rm -f ${NGINX_CONF_DIR}/conf.d/acme-challenge.conf" "normal"
    
    log_success "ACME challenge server configured"
}

# ═══════════════════════════════════════════════════════════════════════════════
# FAKE WEBSITE SERVER (PORT 8080) - КАМУФЛЯЖ
# ═══════════════════════════════════════════════════════════════════════════════

configure_fake_site_server() {
    set_phase "Fake Site Server Configuration"
    
    log_info "Configuring fake website server..."
    
    cat > "${NGINX_CONF_DIR}/conf.d/fake-site.conf" << 'EOF'
# Fake website server
# Serves as camouflage for unrecognized SNI requests
# 
# При подключении с неизвестным SNI показываем "нормальный" сайт

server {
    # Только localhost - внешний доступ через stream module
    listen 127.0.0.1:8080;
    server_name _;
    
    root /var/www/html;
    index index.html index.htm;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    location / {
        try_files $uri $uri/ =404;
    }
    
    # Disable access to hidden files
    location ~ /\. {
        deny all;
    }
    
    # Custom error pages
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
}
EOF

    register_rollback "rm -f ${NGINX_CONF_DIR}/conf.d/fake-site.conf" "normal"
    
    log_success "Fake site server configured"
}

# ═══════════════════════════════════════════════════════════════════════════════
# SETUP FAKE WEBSITE CONTENT
# ═══════════════════════════════════════════════════════════════════════════════

setup_fake_website() {
    set_phase "Fake Website Setup"
    
    log_info "Setting up fake website content..."
    
    mkdir -p "${NGINX_WEBROOT}"
    
    # Check if custom fake site exists
    local fake_site_dir="${SCRIPT_DIR}/../fake-sites"
    if [[ -d "${fake_site_dir}/default" ]]; then
        cp -r "${fake_site_dir}/default/"* "${NGINX_WEBROOT}/"
        log_info "Custom fake site deployed"
    else
        # Create minimal index.html
        cat > "${NGINX_WEBROOT}/index.html" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #f5f5f5; }
        .container { text-align: center; padding: 40px; }
        h1 { color: #333; }
        p { color: #666; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Welcome to nginx</h1>
        <p>If you see this page, the nginx web server is successfully installed and working.</p>
    </div>
</body>
</html>
EOF
        log_info "Default index.html created"
    fi
    
    # Set permissions
    chown -R www-data:www-data "${NGINX_WEBROOT}"
    
    log_success "Fake website setup complete"
}

# ═══════════════════════════════════════════════════════════════════════════════
# DH PARAMETERS
# ═══════════════════════════════════════════════════════════════════════════════

generate_dhparam() {
    local dhparam_file="/etc/nginx/dhparam.pem"
    
    if [[ -f "${dhparam_file}" ]]; then
        log_info "DH parameters already exist"
        return 0
    fi
    
    log_info "Generating DH parameters (this may take a while)..."
    
    openssl dhparam -out "${dhparam_file}" 2048 2>/dev/null
    
    log_success "DH parameters generated"
}

# ═══════════════════════════════════════════════════════════════════════════════
# NGINX CONTROL
# ═══════════════════════════════════════════════════════════════════════════════

test_nginx_config() {
    log_info "Testing nginx configuration..."
    
    if nginx -t 2>&1; then
        log_success "Nginx configuration is valid"
        return 0
    else
        log_error "Nginx configuration test failed"
        return 1
    fi
}

restart_nginx() {
    log_info "Restarting nginx..."
    
    systemctl restart nginx
    
    # Verify nginx is running
    sleep 2
    if systemctl is-active --quiet nginx; then
        log_success "Nginx restarted successfully"
    else
        log_error "Nginx failed to start"
        systemctl status nginx --no-pager
        return 1
    fi
}

reload_nginx() {
    log_info "Reloading nginx configuration..."
    
    if nginx -t 2>&1; then
        systemctl reload nginx
        log_success "Nginx reloaded"
    else
        log_error "Cannot reload - configuration invalid"
        return 1
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# PORT CONFLICT CHECK
# ═══════════════════════════════════════════════════════════════════════════════

check_port_443_conflict() {
    log_info "Checking for port 443 conflicts..."
    
    local pid_on_443=$(ss -tlnp 2>/dev/null | grep ":443 " | grep -oP 'pid=\K\d+' | head -1)
    
    if [[ -n "${pid_on_443}" ]]; then
        local process_name=$(ps -p "${pid_on_443}" -o comm= 2>/dev/null || echo "unknown")
        
        if [[ "${process_name}" == "nginx" ]]; then
            log_info "Nginx already listening on port 443 - OK"
            return 0
        else
            log_warn "Port 443 is in use by: ${process_name} (PID: ${pid_on_443})"
            log_warn "This may cause conflicts. Consider stopping the service."
            return 1
        fi
    fi
    
    log_info "Port 443 is available"
    return 0
}

check_port_80_conflict() {
    log_info "Checking for port 80 conflicts..."
    
    local pid_on_80=$(ss -tlnp 2>/dev/null | grep ":80 " | grep -oP 'pid=\K\d+' | head -1)
    
    if [[ -n "${pid_on_80}" ]]; then
        local process_name=$(ps -p "${pid_on_80}" -o comm= 2>/dev/null || echo "unknown")
        
        if [[ "${process_name}" == "nginx" ]]; then
            log_info "Nginx already listening on port 80 - OK"
            return 0
        else
            log_warn "Port 80 is in use by: ${process_name} (PID: ${pid_on_80})"
            return 1
        fi
    fi
    
    log_info "Port 80 is available"
    return 0
}

# ═══════════════════════════════════════════════════════════════════════════════
# CLEANUP OLD CONFIG
# ═══════════════════════════════════════════════════════════════════════════════

cleanup_default_nginx_config() {
    log_info "Cleaning up default nginx configuration..."
    
    # Remove default site
    rm -f /etc/nginx/sites-enabled/default
    rm -f /etc/nginx/sites-available/default
    
    # Remove old configs that might conflict
    rm -f /etc/nginx/conf.d/default.conf
    
    log_info "Default configurations removed"
}

# ═══════════════════════════════════════════════════════════════════════════════
# MAIN SETUP
# ═══════════════════════════════════════════════════════════════════════════════

setup_nginx() {
    set_phase "Nginx Setup"
    
    # Check for conflicts first
    check_port_443_conflict || true
    check_port_80_conflict || true
    
    # Install nginx
    install_nginx
    
    # Cleanup default config
    cleanup_default_nginx_config
    
    # Configure main nginx.conf
    configure_nginx_main
    
    # Configure ACME challenge server (port 80)
    configure_acme_challenge_server
    
    # Configure SNI routing (port 443)
    configure_sni_routing
    
    # Configure fake site server (port 8080)
    configure_fake_site_server
    
    # Setup fake website content
    setup_fake_website
    
    # Generate DH parameters
    generate_dhparam
    
    # Test and start nginx
    if test_nginx_config; then
        restart_nginx
    else
        log_error "Nginx configuration failed validation"
        return 1
    fi
    
    log_success "Nginx setup completed"
}

# Export functions
export -f setup_nginx
export -f install_nginx
export -f configure_nginx_main
export -f configure_sni_routing
export -f configure_marzban_panel_server
export -f configure_acme_challenge_server
export -f configure_fake_site_server
export -f setup_fake_website
export -f test_nginx_config
export -f restart_nginx
export -f reload_nginx
export -f check_port_443_conflict
export -f check_port_80_conflict
