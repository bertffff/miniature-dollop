#!/bin/bash
#
# Module: nginx.sh
# Purpose: Nginx installation, SNI routing, fake website setup
# Dependencies: core.sh
#

# Strict mode
set -euo pipefail
# Source core module
if [[ -z "${SCRIPT_DIR:-}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    source "${SCRIPT_DIR}/core.sh"
fi

# ═══════════════════════════════════════════════════════════════════════════════
# CONSTANTS
# ═══════════════════════════════════════════════════════════════════════════════

readonly NGINX_CONF_DIR="/etc/nginx"
readonly NGINX_SITES_DIR="${NGINX_CONF_DIR}/sites-available"
readonly NGINX_ENABLED_DIR="${NGINX_CONF_DIR}/sites-enabled"
readonly NGINX_STREAM_DIR="${NGINX_CONF_DIR}/stream.conf.d"
readonly NGINX_HTML_DIR="/var/www/html"

# Fake website template sources
declare -a FAKE_SITE_SOURCES=(
    "https://github.com/cortez24rus/simple-web-templates/archive/refs/heads/main.zip"
)

# ═══════════════════════════════════════════════════════════════════════════════
# NGINX INSTALLATION
# ═══════════════════════════════════════════════════════════════════════════════

is_nginx_installed() {
    command -v nginx &> /dev/null
}

install_nginx() {
    set_phase "Nginx Installation"
    
    if is_nginx_installed; then
        log_info "Nginx already installed: $(nginx -v 2>&1 | cut -d'/' -f2)"
        return 0
    fi
    
    log_info "Installing Nginx..."
    
    # Add Nginx mainline repository for latest version
    if [[ "${OS_ID}" == "ubuntu" ]]; then
        # Ubuntu - use official Nginx PPA
        install_packages software-properties-common
        add-apt-repository -y ppa:ondrej/nginx-mainline 2>/dev/null || true
        apt-get update
    fi
    
    install_packages nginx
    
    register_rollback "apt-get remove -y nginx && rm -rf ${NGINX_CONF_DIR}" "normal"
    
    log_info "Nginx installed: $(nginx -v 2>&1 | cut -d'/' -f2)"
}

# ═══════════════════════════════════════════════════════════════════════════════
# NGINX CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

configure_nginx_main() {
    set_phase "Nginx Main Configuration"
    
    log_info "Configuring main Nginx settings..."
    
    # Backup original config
    backup_file "${NGINX_CONF_DIR}/nginx.conf"
    
    cat > "${NGINX_CONF_DIR}/nginx.conf" << 'EOF'
user www-data;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

# Maximum open file descriptors
worker_rlimit_nofile 65535;

events {
    worker_connections 65535;
    multi_accept on;
    use epoll;
}

http {
    ##
    # Basic Settings
    ##
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_tokens off;

    # Buffer sizes
    client_body_buffer_size 16K;
    client_header_buffer_size 1k;
    client_max_body_size 8m;
    large_client_header_buffers 4 8k;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings
    ##
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    ##
    # Logging Settings
    ##
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript application/xml;

    ##
    # Virtual Host Configs
    ##
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}

# Stream module for SNI routing (TCP proxy)
stream {
    log_format stream_log '$remote_addr [$time_local] '
                          '$protocol $status $bytes_sent $bytes_received '
                          '$session_time "$upstream_addr" '
                          '"$ssl_preread_server_name"';
    
    access_log /var/log/nginx/stream.log stream_log;
    
    include /etc/nginx/stream.conf.d/*.conf;
}
EOF
    
    register_rollback "rm -f ${NGINX_CONF_DIR}/nginx.conf" "normal"
    
    # Create stream directory
    mkdir -p "${NGINX_STREAM_DIR}"
}

configure_sni_routing() {
    set_phase "SNI Routing Configuration"
    
    log_info "Configuring SNI-based routing..."
    
    # Ensure Reality destination is set
    local reality_dest="${REALITY_DEST:-www.microsoft.com}"
    local panel_domain="${PANEL_DOMAIN:-}"
    local cdn_domain="${CDN_DOMAIN:-}"
    
    # Create SNI routing configuration
    cat > "${NGINX_STREAM_DIR}/sni-router.conf" << EOF
# SNI-based traffic routing
# Generated by Marzban Ultimate Installer

# SNI to backend mapping
map \$ssl_preread_server_name \$backend {
    # Reality profile - forward to Xray Reality handler
    ~^(www\.)?(microsoft|apple|samsung|nvidia|google)\.com\$    xray_reality;
    ~^dl\.google\.com\$                                          xray_reality;
    
EOF

    # Add panel domain if configured
    if [[ -n "${panel_domain}" ]]; then
        cat >> "${NGINX_STREAM_DIR}/sni-router.conf" << EOF
    # Panel domain - proxy to Marzban
    ${panel_domain}                                              marzban_panel;
    
EOF
    fi
    
    # Add CDN domain if configured
    if [[ -n "${cdn_domain}" ]]; then
        cat >> "${NGINX_STREAM_DIR}/sni-router.conf" << EOF
    # CDN domain - forward to Xray WebSocket handler
    ${cdn_domain}                                                xray_websocket;
    
EOF
    fi
    
    # Add default fallback
    cat >> "${NGINX_STREAM_DIR}/sni-router.conf" << EOF
    # Default - serve fake website
    default                                                      fake_site;
}

# Upstream definitions
upstream xray_reality {
    server 127.0.0.1:${REALITY_PORT:-8443};
}

upstream xray_websocket {
    server 127.0.0.1:${WS_PORT:-8444};
}

upstream marzban_panel {
    server 127.0.0.1:${MARZBAN_PORT:-8000};
}

upstream fake_site {
    server 127.0.0.1:8080;
}

# Main listener on port 443
server {
    listen 443 reuseport;
    listen [::]:443 reuseport;
    
    proxy_pass \$backend;
    proxy_protocol off;
    
    ssl_preread on;
    
    # Proxy settings
    proxy_connect_timeout 10s;
    proxy_timeout 300s;
}
EOF
    
    register_rollback "rm -f ${NGINX_STREAM_DIR}/sni-router.conf" "normal"
    
    log_success "SNI routing configured"
}

configure_fake_site_server() {
    set_phase "Fake Site Server Configuration"
    
    log_info "Configuring fake website server..."
    
    # Create configuration for fake site
    cat > "${NGINX_CONF_DIR}/conf.d/fake-site.conf" << 'EOF'
# Fake website server
# Serves as camouflage for unrecognized SNI requests

server {
    listen 127.0.0.1:8080;
    server_name _;
    
    root /var/www/html;
    index index.html index.htm;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    location / {
        try_files $uri $uri/ =404;
    }
    
    # Disable access to hidden files
    location ~ /\. {
        deny all;
    }
    
    # Error pages
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
}
EOF
    
    register_rollback "rm -f ${NGINX_CONF_DIR}/conf.d/fake-site.conf" "normal"
}

# ═══════════════════════════════════════════════════════════════════════════════
# FAKE WEBSITE CONTENT
# ═══════════════════════════════════════════════════════════════════════════════

generate_random_title() {
    local titles=(
        "Welcome"
        "Home"
        "Professional Services"
        "Portfolio"
        "About Us"
        "Company"
        "Creative Studio"
        "Digital Agency"
        "Solutions"
        "Consulting"
    )
    echo "${titles[$RANDOM % ${#titles[@]}]}"
}

create_default_fake_site() {
    local site_dir="${1:-${NGINX_HTML_DIR}}"
    
    log_info "Creating default fake website..."
    
    mkdir -p "${site_dir}"
    
    local random_title
    random_title=$(generate_random_title)
    
    cat > "${site_dir}/index.html" << EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${random_title}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            text-align: center;
            padding: 40px;
            max-width: 600px;
        }
        h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            font-weight: 300;
        }
        p {
            font-size: 1.2rem;
            opacity: 0.9;
            line-height: 1.6;
        }
        .status {
            margin-top: 2rem;
            padding: 1rem 2rem;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            display: inline-block;
        }
        .dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #4ade80;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>${random_title}</h1>
        <p>We're working on something exciting. Our new website is coming soon.</p>
        <div class="status">
            <span class="dot"></span>
            All systems operational
        </div>
    </div>
</body>
</html>
EOF
    
    # Create 404 page
    cat > "${site_dir}/404.html" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page Not Found</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: #f5f5f5;
        }
        .container { text-align: center; }
        h1 { color: #333; font-size: 6rem; margin: 0; }
        p { color: #666; }
        a { color: #667eea; }
    </style>
</head>
<body>
    <div class="container">
        <h1>404</h1>
        <p>Page not found. <a href="/">Return home</a></p>
    </div>
</body>
</html>
EOF
    
    chown -R www-data:www-data "${site_dir}"
}

setup_fake_website() {
    set_phase "Fake Website Setup"
    
    local site_dir="${NGINX_HTML_DIR}"
    local temp_dir
    temp_dir=$(mktemp -d)
    
    log_info "Setting up fake website for camouflage..."
    
    register_rollback "rm -rf ${temp_dir}" "cleanup"
    
    # Try to download template
    local source_url="${FAKE_SITE_SOURCES[$RANDOM % ${#FAKE_SITE_SOURCES[@]}]}"
    
    if wget -q -O "${temp_dir}/templates.zip" "${source_url}" 2>/dev/null; then
        log_info "Downloaded website templates"
        
        # Extract
        unzip -q "${temp_dir}/templates.zip" -d "${temp_dir}/extracted" 2>/dev/null || {
            log_warn "Failed to extract templates, using default"
            create_default_fake_site "${site_dir}"
            rm -rf "${temp_dir}"
            return 0
        }
        
        # Find template directories
        local templates_root
        templates_root=$(find "${temp_dir}/extracted" -maxdepth 2 -type d -name "*templates*" 2>/dev/null | head -1)
        
        if [[ -z "${templates_root}" ]]; then
            templates_root="${temp_dir}/extracted"
        fi
        
        # Get available templates
        local available_templates
        available_templates=$(find "${templates_root}" -maxdepth 1 -type d \
            ! -name ".*" ! -name "assets" ! -name "__MACOSX" \
            -printf "%f\n" 2>/dev/null | grep -v "^$" | grep -v "templates" || true)
        
        if [[ -n "${available_templates}" ]]; then
            local selected
            selected=$(echo "${available_templates}" | shuf -n1)
            
            if [[ -d "${templates_root}/${selected}" ]]; then
                log_info "Selected template: ${selected}"
                
                rm -rf "${site_dir:?}"/*
                cp -a "${templates_root}/${selected}/." "${site_dir}/" 2>/dev/null || true
                
                # Clean up metadata
                find "${site_dir}" -name "README*" -delete 2>/dev/null || true
                find "${site_dir}" -name ".git*" -exec rm -rf {} + 2>/dev/null || true
                find "${site_dir}" -name "LICENSE*" -delete 2>/dev/null || true
                
                # Randomize title
                if [[ -f "${site_dir}/index.html" ]]; then
                    local random_title
                    random_title=$(generate_random_title)
                    sed -i "s|<title>[^<]*</title>|<title>${random_title}</title>|g" \
                        "${site_dir}/index.html" 2>/dev/null || true
                fi
                
                chown -R www-data:www-data "${site_dir}"
                rm -rf "${temp_dir}"
                log_success "Fake website installed: ${selected}"
                return 0
            fi
        fi
    fi
    
    # Fallback to default
    log_warn "Using default fake website"
    create_default_fake_site "${site_dir}"
    rm -rf "${temp_dir}"
}

# ═══════════════════════════════════════════════════════════════════════════════
# DH PARAMETERS
# ═══════════════════════════════════════════════════════════════════════════════

generate_dhparam() {
    local dhparam_file="${NGINX_CONF_DIR}/dhparam.pem"
    
    if [[ -f "${dhparam_file}" ]]; then
        log_info "DH parameters already exist"
        return 0
    fi
    
    log_info "Generating DH parameters (this may take a few minutes)..."
    
    # Use 2048 bits for balance of security and generation time
    openssl dhparam -out "${dhparam_file}" 2048 2>/dev/null &
    local pid=$!
    
    # Show progress
    local spinner='|/-\'
    local i=0
    while kill -0 "${pid}" 2>/dev/null; do
        printf "\r[%c] Generating DH parameters..." "${spinner:i++%4:1}"
        sleep 0.5
    done
    
    wait "${pid}"
    printf "\r                                          \r"
    
    chmod 600 "${dhparam_file}"
    log_success "DH parameters generated"
}

# ═══════════════════════════════════════════════════════════════════════════════
# NGINX CONTROL
# ═══════════════════════════════════════════════════════════════════════════════

test_nginx_config() {
    log_info "Testing Nginx configuration..."
    
    if nginx -t 2>&1; then
        log_success "Nginx configuration is valid"
        return 0
    else
        log_error "Nginx configuration test failed"
        return 1
    fi
}

reload_nginx() {
    log_info "Reloading Nginx..."
    
    if test_nginx_config; then
        systemctl reload nginx
        log_success "Nginx reloaded"
    else
        log_error "Cannot reload Nginx due to configuration errors"
        return 1
    fi
}

restart_nginx() {
    log_info "Restarting Nginx..."
    
    if test_nginx_config; then
        systemctl restart nginx
        log_success "Nginx restarted"
    else
        log_error "Cannot restart Nginx due to configuration errors"
        return 1
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# CLEANUP
# ═══════════════════════════════════════════════════════════════════════════════

remove_default_site() {
    log_info "Removing default Nginx site..."
    
    rm -f "${NGINX_ENABLED_DIR}/default"
    rm -f "${NGINX_SITES_DIR}/default"
}

# ═══════════════════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════════════════

setup_nginx() {
    install_nginx
    remove_default_site
    configure_nginx_main
    configure_sni_routing
    configure_fake_site_server
    setup_fake_website
    generate_dhparam
    
    # Test and start
    if test_nginx_config; then
        systemctl enable nginx
        systemctl restart nginx
        log_success "Nginx setup completed"
    else
        log_error "Nginx setup failed - configuration errors"
        return 1
    fi
}

# Export functions
export -f setup_nginx
export -f install_nginx
export -f configure_sni_routing
export -f setup_fake_website
export -f test_nginx_config
export -f reload_nginx
export -f restart_nginx
